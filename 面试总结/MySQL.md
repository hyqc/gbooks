# MySQL面试总结

## 以MySQL为例，如何对SQL进行优化？
- 开启慢查询
- 对SQL执行explain执行计划，查看分析结果
- 建立适当的索引：主键索引、二级索引（辅助索引）、前缀索引、联合索引、唯一键索引等
- 写SQL是避免索引失效：最左匹配原则

## MySQL发生了死锁怎么办？
插入意向锁和间隙锁不兼容，间隙锁和间隙锁兼容
- 快照读：普通select语句（mvcc）
- 当前读：select ... for update 语句(加记录锁+间隙锁)
死锁发生的场景：
1. 事务A：select id from user where id = 1 for update; 加排他锁（间隙锁+记录锁）
2. 事务B：select id from user where id = 4 for update; 加排他锁（间隙锁+记录锁）
3. 事务A：insert into user (`id`) values (2); 插入意向锁（记录不存着排它锁变成间隙锁）
4. 事务B：insert into user (`id`) values (6); 插入意向锁（间隙锁已存在是，新的插入会先获取插入意向锁）
事务A和B的第一步都开启了next-lock间隙锁，第二步要获取插入意向锁，事务A等待事务B释放间隙锁，事务B等待事务A释放间隙锁，造成循环等待死锁（循环等待(死循环)，请求保持(占有资源不放)、互斥(只能被一个人占有)、不可剥夺(自己释放)）

## MySQL的主键使用顺序和乱序有什么影响？为什么？
乱序写入会造成：
- 乱序ID，会造成写入的数据不在页缓冲区，那么插入的时候会先从磁盘读取目标页到内存，从而导致到了的随机I/O，影响性能和浪费内存空间。如果是有序写入，一般在相同的内存页中，或者下一个内存页中，相对于乱序会生成很少的内存页占用，少量磁盘I/O。
- 可能会造成大量的页分裂，每页16kb，页越多占用的空间越大，且页分裂会造成数据移动，页面变得稀疏，导致数据碎片化。

### 解决乱序主键页分离、数据碎片化、内存占用问题？
使用 optimize table 语句重建表并优化页填充可以优化随机乱序ID的影响。

### optimize table原理
把分散存储的数据放在一块，清除碎片，回收闲置的数据库空间。

#### 使用场景
- 乱序主键写入，造成的内存页分散，大量随机I/O，及数据碎片化问题
- 频繁的插入和删除数据，造成的磁盘空间（数据空间、索引位）的没有被收回

## MySQL事务的隔离级别？
- 读未提交：事务修改数据未commit，允许其他事务读取：脏读(读到了别人修改的数据)、不可重复读(前后读取的数据不一致)、幻读（前后数据量不一致）
- 读已提交：事务修改数据，只有commit了的，才允许被其他事务读取，每个select生成read view快照
- 可重复读：事务执行中看到的数据跟事务开始执行时保持一致，快照读（普通select，不加锁），当前读（select for update，加next-key lock ），每次事务开启时生成read view，事务中使用这个快照。
- 串行化：事务排队

## MySQL事务的特性：
- 原子性：通过回滚日志 undo.log保证
- 持久性：通过重做日志 redo.log保证
- 隔离性：通过mvcc（快照读）或加锁保证（当前读）
- 一致性：通过原子性、持久性、隔离性一起保证

## Read View
Read View的四个字段：
- creator_trx_id：创建这个Read View的事务的ID
- max_trx_id：下一个要创建的事务的ID，当前系统中最多的事务ID+1
- m_ids：创建read view时，当前数据库中已经创建且未commit的活跃事务id列表
- min_trx_id：m_ids中最小的事务ID
聚簇索引的行的隐藏列：
- trx_id：事务ID
- roll_pointer：旧版本在undo.log中的记录指针，版本记录指的是undo.log中的数据
通过判断当前事务和min、max事务ID的大小，得出当前记录对该事务的可见性，这个就是MVCC多版本并发控制。