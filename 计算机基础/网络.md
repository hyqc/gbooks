# 网络

## TCP/IP网络模型

- 应用层：为用户提供应用功能，如HTTP、FTP、DNS、SMTP等
- 传输层：为应用层提供网络服务支持：TCP、UDP协议
- 网络层：提供IP协议支持
- 网络接口层：网络层生成IP头部之后，网络接口层想IP头部增加MAC头部，并封装到数据帧发送到网络上

![TCP/IP网络模型封装模式](./img/tcpip_layer.webp)

## 浏览器地址栏输入地址回车后发生了什么？
网络请求的流程图：
```mermaid
flowchart TD
    a1["应用层：软件服务"]
    a2["传输层：TCP/UDP"]
    a3["网络层：IP"]
    a4["网络接口层：数据帧"]
    a5["交换机"]
    a6["路由器"]
    a7["互联网"]
    b1["路由器"]
    b2["交换机"]
    b3["网络接口层：数据帧"]
    b4["网络层：IP"]
    b5["传输层：TCP/UDP"]
    b6["应用层：软件服务"]

    a1-->a2-->a3-->a4-->a5-->a6-->a7
    a7-->b1-->b2-->b3-->b4-->b5-->b6
```

- URL地址解析：解析出域名、协议、资源路径等，生成HTTP请求消息
- DNS域名解析：向DNS服务器查询域名对应的IP（先查本地，再查远程）
- 操作系统协议栈
- 建立TCP连接：三次握手建立可靠连接
- IP模块：将数据封装成网络包
- MAC：在网络包的IP头部前面加上MAC头部（接收方和发送方的MAC地址）
- 网卡：数据出口，将二进制数据信息转换为电信号发送出去
- 交换机：将网络包原样转发到目的地，交换机工作在MAC层（二层网络设备）
- 路由器：网络包经过交换机后到达路由器，并被转发到下一个路由器或目标设备
- 数据抵达服务器后逐层解析

![数据在网络的传输](./img/client-server.webp)



## TCP三次握手
客户端一发一收，服务端一收一发，客户端和服务端共经历3次确认（握手）
- 第一次：开始客户端向服务端都处于closed状态，服务端主动监听某个端口并处于Listen监听状态，客户端主动发起连接请求，发送SYN=client_isn序列号后处于SYN-SENT状态
- 第二次：服务端收到连接请求后，返回SYN=server_isn，并且ACK=client_isn+1客户端的SYN后处于SYN-RCVD状态
- 第三次：客户端收到服务端发送的SYN和ACK后，向服务端发送SYN确认的ACK==server_isn+1后处于ESTABLISHED状态

```mermaid
    sequenceDiagram
        客户端-->服务端: close
        服务端-->>客户端: 监听端口 LISTEN
        客户端->>服务端: 主动发起连接请求 SYN seq_num = client_isn，SYN_SENT
        服务端->>客户端: 返回SYN和ACK，ACK=client_isn+1 seq_num=server_isn，SYN_RCVE，ESTABLISED
        客户端->>服务端: 确认客户端ACK，并发送ACK，ack=server_isn+1，服务端确认ack并处于ESTABLISED

```
1. 为什么是三次握手，而不是四次或五次六次？
   因为对于客户端和服务端建立起可靠连接，需要客户端告诉服务器准备好了，可以发送数据了，同时服务端也要告诉客户端准备好了可以接收了，这个过程首先需要客户端向服务端发起确认是否可以建立连接，服务端收到信号后告诉客户端准备好了，客户端发送邀约请求需要一次，服务端告诉客户端准备好了一次，此时客户端准备OK，服务端也要告诉客户端是否准备好，因此也需要向客户端发送信号，告诉服务端可以发送了，同时客户端也要向服务端发送确认信号，这么看共需要四次，但是可以看到服务端回复客户端和服务端第一次通知客户端是可以合并的，因此只需要3次握手就够了，增加4次5次就是重复的非必要操作。

## HTTP 和 HTTPS