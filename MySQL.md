# MySQL

## 常用操作命令
- mysql -h$ip -u$user -p ：登录mysql服务
- show processlist：查看当前mysql服务有多少客户端连接
- kill connection +连接ID：手动端口空闲连接
- show variables like 'max_connections'：查看mysql最大支持的连接数

## 一条查询SQL语句的执行顺序是怎样的？[待定]
示例SQL：
```sql

```

## 执行一条SQL语句，期间发生了什么？
- 连接器：MySQL基于TCP协议建立连接的，建立连接，管理连接、验证身份密码
- 查询缓存：如果查询命中查询缓存，则直接返回查询结果，否则向下执行，8.0已删除查询缓存（为什么）
- 解析器解析SQL：对SQL语句进行词法分析、语法分析，构建语法树
- 预处理器：检查表和字段是否存在，展开*为全部字段
- 优化器：选择查询成本最小的执行计划
- 执行器：根据执行计划执行SQL语句，从存储引擎读取记录返回给客户端

### 连接器
与MySQL服务器建立TCP连接：
```bash
$ mysql -h$ip -u$user -p回车输入密码
```
- -h：mysql服务的IP地址，如果是在本机上可以不填
- -u：用户名
- -p：密码

### 查询缓存

### 解析器
- 词法分析：根据输入的SQL语句，分析出关键字，构建SQL语法树
- 语法分析：根据词法分析构建的语法树，判断输入的SQL语法是否正确，不正确直接抛出异常结束

### 执行SQL-预处理器
- 判断SQL语句中的表和字段是否存在
- 对select * 的 * 展开为表的字段

### 执行SQL-优化器
为输入的SQL制定一个执行计划，优化器基于查询成本来决定使用哪一个索引来查询

### 执行器
与存储引擎交互获取记录集

#### 索引下推

## 索引
### 索引分类
- 按数据结构：B+Tree索引、Hash索引、Full-Text索引
- 按物理存储：聚簇索引（主键索引）、二级索引（辅助索引）
- 按字段特性：主键索引、唯一索引、普通索引、前缀索引
- 按字段个数：单列索引、联合索引

### B+Tree索引
- 非叶子节点只存储索引，叶子节点存放数据
- 每一个叶子节点都有两个指针，分别存放上一个节点和下一个节点，构成双休链表
- 索引和数据都存储在磁盘，读取一个节点相当于一次IO操作
- B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，意味着存储千万数据只需要最多3-4次IO就可以找到，查询效率相对于二叉树和B树高很多


### 主键索引
主键索引的非叶子节点只存放主键（索引值），叶子节点存放完整的行记录信息和上一个及下一个节点的指针

### 二级索引
二级索引的非叶子节点只存放索引值，叶子节点存放主键值，并不存储实际数据

### 回表
通过二级索引（辅助索引，按物理存储）查询到记录的主键，在通过主键到主键索引获取这个主键对应的行数据的过程叫回表。简单点说，就是需要查询两次B+Tree树索引（二级索引+主键索引）才能获取到结果的查询过程叫回表。
示例SQL：
```sql
select * from users where name = 'a'
```
其中name字段建立了B+Tree索引，主键是ID。此时为了获得name = a 的用户的详细信息，需要先在name索引上查找到主键，再回表按照主键索引查询获得a用户的记录。

### 覆盖索引
在二级索引中就可以查询到结果的查询过程就叫覆盖索引查询。
示例SQL：
```sql
select id from users where name = 'a'
```
其中name字段建立了B+Tree索引，主键是ID。因为name索引的叶子节点上存放的是主键的值，就是这个a用户的主键id值，此时不用回表获取结果，直接从二级索引中获得了结果的查询过程就叫覆盖索引查询。

### 问题

#### 为什么才有B+Tree树而不是BTree树作为MySQL索引的结构？
- B+Tree只有叶子节点存储数据，而BTree数据的非叶子节点也要存储数据，所以B+Tree的单个节点的数据量更小，在相同磁盘IO此次下，B+Tree可以查询更多的节点
- B+Tree的叶子节点采用的是双向链表，更适合MySQL的范围查询，而BTree无法做到这一点。

#### B+Tree vs Hash
Hash索引更适合做等值查询，但是不适合做范围查询


#### B+Tree vs 二叉树
二叉树的子节点最多只能有两个，这样会造成数据量越大，二叉树的层数越高，查询的IO次数越多，性能越差，而B+Tree的子节点可以有很多个，可以减少磁盘的IO次数。
